arXiv:2302.01225v1 [cs.CR] 2 Feb 2023

# Asymmetric Cryptosystem Using Careful Synchronization

Jakub Ruszil

Jagiellonian University  $Cracow$ Poland

February  $2023$ 

Abstract

We present public-private key cryptosystem which utilizes the fact that checking whether a partial automaton is carefully synchronizing is  $PSPACE$ -complete, even in the case of a binary alphabet.

# 1 Introduction

Cryptography is essential branch of mathematics since the ancient times. It's main purpose is to ensure the privacy of information between sender and receiver sent through a possibly observed channel. Nowadays we differ symmetric  $\text{cryptography}$  - where the key used to cipher the message is the same as the one to decipher it - and asymmetric, where the key to cipher the message is commonly known and the one to decipher it is known only to the receiver of the message. In other words asymmetric cryptography is referred to as a public key cryptography, or a public-private key cryptography. The idea of public key cryptography was first mentioned in a confidential report GCHQ [4] (UK Gov ernment Communications Headquarters) and later independently by Diffie and Hellman in 1976 [27] along with the first practical public key cryptosystem based on knapsack problem. The mostly known asymmetric cryptosystem (RSA) was invented by Rivest, Shamir and Adleman in 1978 [17] and is applicable since then to encryption and digital signatures.

The concept of synchronization of finite automata is essential in various areas of computer science. It consists in regaining control over a system by applying a specific set of input instructions. These instructions lead the system to a fixed state no matter in which state it was at the beginning. The idea of synchronization has been studied for many classes of complete deterministic finite automata (DFA) [1, 2, 5, 9, 10, 16, 18, 20, 23, 22, 24, 25] and non-deterministic 

1

finite automata [\[7\]](#page-7-1), [\[14\]](#page-7-1). One of the most famous longstanding open problems in automata theory, known as Černý Conjecture, states that for a given synchronizing DFA with  $n$  states one can always find a synchronizing word of length at most  $(n-1)^2$ . This conjecture was proven for numerous classes of automata, but the problem is still not solved in general case. The concept of synchronization has been also considered in coding theory [\[3\]](#page-7-1), [\[8\]](#page-7-1), parts orienting in manufacturing [\[5\]](#page-7-1), [\[15\]](#page-7-1), testing of reactive systems [\[19\]](#page-7-1) and Markov Decision Processes [\[11\]](#page-7-1), [\[12\]](#page-7-1).

Allowing no outgoing transitions from some states for certain letters helps us to model a system for which certain actions cannot be accomplished while being in a specified state. This leads to the problem of finding a synchronizing word for a finite automaton, where transition function is not defined for all states. Notice that this is the most frequent case, if we use automata to model real-world systems. In practice, it rarely happens that a real system can be modeled with a DFA where transition function is total. The transition function is usually a partial one. This fact motivated many researchers to investigate the properties of partial finite automata relevant to practical problems of synchronization.

We know that, in general case, checking if a partial automaton can be synchronized is PSPACE-complete [13] even for binary alphabet [26] and those facts are essential in our latter considerations.

In this paper we present a public key cryptosystem utilizing fact, that checking if the PFA is carefully synchronizing is PSPACE-complete. This is however not the first attempt of trying to develop asymmetric cryptosystems with the notion of finite automata. Public key cryptography on finite automata with output is discussed in  $[21]$  and uses the notion of invertible automata to provide the hard computational problem, inevitable to design such cryptosystem.

The paper is organized as follows. In the section  $2$  we provide with the basic notions and facts about synchronization of automata. In the sections  $3$  and  $4$ we present basic method of encryption and decryption using our cryptosystem. In the section  $5$  we state couple of additional improvements to ensure better security. Finally we conclude the paper in the section 6 along with possible further research to the topic.

# 2 Preliminaries

Partial finite automaton (PFA) is an ordered tuple  $A = (Q, \Sigma, \delta)$ , where  $\Sigma$  is a finite set of letters, Q is a finite set of states and  $\delta: Q \times \Sigma^* \to Q$  is a transition function, possibly not everywhere defined. In this definition we omit initial and final states, since they are not relevant to the problem of synchronization. For  $w \in \Sigma^*$  and  $q \in Q$  we define  $\delta(q, w)$  inductively:  $\delta(q, \epsilon) = q$  and  $\delta(q, aw) = \delta(\delta(q, a), w)$  for  $a \in \Sigma$ , where  $\epsilon$  is the empty word and  $\delta(q, a)$  is defined. A word  $w \in \Sigma^*$  is called *carefully synchronizing* if there exists  $\overline{q} \in Q$  such that for every  $q \in Q$ ,  $\delta(q, w) = \overline{q}$  and all transitions  $\delta(q, w')$ , where w' is any prefix of  $w$ , are defined. A PFA is called *carefully synchronizing* 

2

admits any carefully synchronizing word. For a given  $\mathcal{A}$  we define its *power automaton* (which is itself a PFA) as  $\mathcal{P}(\mathcal{A}) = (2^Q, \Sigma, \tau)$ , where  $2^Q$  stands for the set of all subsets of  $Q$ , and  $\Sigma$  is the same as in  $\mathcal{A}$ . The transition function  $\tau: 2^Q \times \Sigma \to 2^Q$  is defined as follows. Let  $Q' \subseteq Q$ . For every  $a \in \Sigma$  we define  $\tau(Q',a) = \bigcup_{q \in Q'} \delta(q,a)$  if  $\delta(q,a)$  is defined for all states  $q \in Q'$ , otherwise  $\tau(Q',a)$  is not defined. We also note Q.w as an action of a word w on a set of states Q under the function  $\delta$ . Let  $S \subseteq Q$ . Then we denote  $S \cdot w^{-1}$  as a preimage of  $S$  under the action of a word  w .

We note that the above concepts can also be considered for *deterministic* finite *automata* (DFA), for which the transition function is total. We define an a-cluster to be a DFA  $\mathcal{A} = (Q, \{a\}, \delta)$  such that the automaton is connected. In other words it means that such automaton is a cycle on letter  $a$  with paths that leads to the states of that cycle. The set of states that induce a cycle in the  $a$ -cluster is referred to as the *center* of the cluster. The *depth* of the cluster is the length of the longest path to the center of the cluster. If  $q$  belongs to the center of the a-cluster, the *branch* of the state  $q$  are the states that has a path to  $q$  that does not have any other state belonging to the center. *Destination* of the branch is a state in the center that has an in-transition from the last state of the branch. Example of the  $a$ -cluster is depicted on Figure 1.

![](_page_2_Figure_2.jpeg)

Figure 1: Example of the  $a$ -cluster

Center of that a-cluster is the set  $\{3, 4, 5, 6\}$ , the depth is 2 and there are two branches:  $b_1 = \{1, 2\}$  and  $b_2 = \{7\}$ . Destination of the branch  $b_1$  is the state 3 and of the branch  $b_2$  is state 4.

We define the sum of two automata  $\mathcal{A} = (Q_1, \Sigma_1, \delta_1)$  and  $\mathcal{B} = (Q_2, \Sigma_2, \delta_2)$  as  $\mathcal{A} \cup \mathcal{B} = (Q_1 \cup Q_2, \Sigma_1 \cup \Sigma_2, \delta_1 \cup \delta_2)$ . We can now state the obvious fact, useful to decide whether a given PFA is carefully synchronizing.

3

**Fact 1.** Let  $\mathcal{A}$  be a PFA and  $\mathcal{P}(\mathcal{A})$  be its power automaton. Then  $\mathcal{A}$  is carefully synchronizing if and only if for some state  $q \in Q$  there exists a path in  $\mathcal{P}(\mathcal{A})$  from Q to  $\{q\}$ . The shortest synchronizing word for A corresponds to the shortest such path in  $\mathcal{P}(\mathcal{A})$ .

An example of a carefully synchronizing automaton  $\mathcal{A}_{car}$  is depicted in Fig. 2. One of its carefully synchronizing words is  $aa(ba)^3bbab$ .

![](_page_3_Figure_2.jpeg)

Figure 2: A carefully synchronizing automaton  $\mathcal{A}_{car}$ .

We recall the result of Vorel [\[26\]](#page-14-1) about the complexity of deciding whether a PFA is carefully 

**Theorem 1.** Given a PFA  $A = (Q, \Sigma, \delta)$ , checking if  $A$  is carefully synchronizing is  $PSPACE$ -complete even for  $|\Sigma| = 2$ .

Further we assume that  $\Sigma = \{a, b\}$  and the letter a is defined for all the states wherever not mentioned otherwise. Having that we can go to the description of our method.

# 3 Basic encryption

Let a plain text be the word  $u \in \{0, 1\}^*$ . Choose a public key to be a carefully synchronizing PFA  $\mathcal{A} =

4

(Q, \Sigma, \delta)$  and a private key to be any word w that carefully synchronizes  $\mathcal{A}$ . For simplicity of further statements we note  $\mathcal{A}_i =$  $(Q_i, \Sigma, \delta_i)$  to be isomorphic to  $\mathcal{A}$  for any  $i \in \mathbb{N}$ . First we describe a construction that 

Define an automaton  $\mathcal{P} = (\{p_1, p_2, \ldots, p_{\|u\|+1}\}, \{0, 1\}, \gamma)$  where  $\gamma$  is defined as follows: for  $i \in \{1, \ldots, |u|+1\}$  set  $\gamma(p_{i-1}, u_i) = p_i$ , where  $u_i$  is *i*-th letter of a word  $u$ . In other words we encode our plaintext in the form of a directed path, where consecutive edges correspond to the consecutive letters of the word  $u$ . Encryption consists of four steps:

- 1. Compute  $\mathcal{B} = \bigcup_{i=1}^{|u|+1} \mathcal{A}_i$  and denote  $\bigcup_{i=1}^{|u|+1} \delta_i = \rho, \ P = \bigcup_{i=1}^{|u|+1} Q_i$
- 2. for any transition  $(p_i, p_j)$  in  $\mathcal{P}$ , labelled with a letter  $x \in \{0, 1\}$  choose any pair of states  $q^i \in Q_i$  and  $q^j \in Q_j$ , and set  $\rho(q^i, x) = q^j$ ,
- 3. for all  $i \in \{1, .., |u|+1\}$  and for every letter  $a \in \Sigma$ , if  $q^i \in Q_i$  and  $\delta(q^i, a)$  is undefined, then choose any j and any state  $q^j \in Q_j$  and set  $\rho(q^i, a) = q^j$ ,
- 4. for all  $i \in \{1, ..., |u| + 1\}$  choose  $k_i \in \mathbb{N}$ . Choose  $k_i$  pairs  $(q_p^i, q_r^i)$  and a letter  $x \in \{0, 1\}$  and define  $\rho(q_p^i, x) = q_r^i$

Automaton  $\mathcal{B}$  is our ciphertext. It is straightforward from the construction, that computing such automaton is polynomial in terms of  $Q, \Sigma$  and length of the plaintext. We also state two obvious observations.

**Fact 2.** After removing letters  $x \in \{0,1\}$  from automaton  $\mathcal{B}$  we obtain a DFA over  $\Sigma$ .

**Fact 3.** After removing letters  $a \in \Sigma$  from automaton  $\mathcal{B}$  we obtain a digraph labelled with letters  $x \in \{0, 1\}$  with longest path between the vertices of length 1.

Procedure of encrypting the word 01 is depicted on figures  $3, 4, 5$  and  $6$ . As a public key we take the automaton depicted on Figure 2.

5

![](_page_5_Figure_0.jpeg)

Figure 3: First step of encryption.  $\Box$ 

The first step involves summation of three copies of the public key that correspond to the three vertices of the word  $01$  encoded as a labeled path. The first vertex of the path corresponds to the automaton induced by the states with suffix  $a$ , the second - by the states with the suffix  $b$ , and the third - by the suffix  $c.$ 


6

![](_page_6_Figure_0.jpeg)

Figure 4: Second step of encryption.

The second step involves adding the transitions  $0$  and  $1$  to the states of automata that correspond to the in and out vertices of the transition. In the above example we define transition  $\rho(5a, 0) = 2b$ , which corresponds to the first transition of the encoded word, and  $\rho(12b, 1) = 9c$ , which corresponds to the second transition of the encoded word. Transitions added in this step are **bolded**.

7

![](_page_7_Figure_0.jpeg)

Figure 5: Third step of encryption.  $\mathcal{L}$ 

The third step involves adding transitions from  $\Sigma$  to those states in  $\mathcal{B}$ , which have undefined transitions for letters from  $\Sigma$ . In that case we add only b letters. For example we defined  $\rho(1a, b) = 2b$ . We should act similarly for all states, for which  $b$  is undefined, but we have only added some of the necessary transitions so the figure is readable.

8

![](_page_8_Figure_0.jpeg)

Figure 6: Fourth step of encryption.

The last step involves adding some number of transitions under letters from the alphabet  $\{0, 1\}$  between states belonging to the same copy of a public key in  $\mathcal{B}$ . In that case we have added transition  $\rho(9a, 0) = 10a$  (first copy), transitions  $\rho(7b, 1) = 10b$  and  $\rho(8b, 1) = 3b$  (second copy) and transition  $\rho(12c, 0) = 7c$  (third copy).

### Basic decryption $4$

For that section we assume that we have a ciphertext automaton  $\mathcal{B} = (P, \Sigma, \rho)$  constructed from a public key  $\mathcal{A} = (Q, \Sigma, \delta)$ , and that we know a private key  $w$  which is a carefully synchronizing word for the automaton  $\mathcal{A}$ . First we state a lemma.

**Lemma 1.** Let  $Q.w = q_l$ . After removing letters  $x \in \{0,1\}$  from automaton  $B$  we have that  $P.w = \{q_l^1, q_l^2, ..., q_l^{|u|+1}\}\$ .

9

*Proof.* It is immediate from construction, since we have not removed any transitions from  $\Sigma$  within any  $Q_i$ , that for any  $Q_i \in P$  holds  $Q_i.w = q_l^i$ , since  $w$ 
carefully synchronizes  $\mathcal{A}$  and each  $Q_i$  on  $\Sigma$  induces an isomorphic copy of  $\mathcal{A}$ . So
we have, that  $\{q_l^1, q_l^2, ..., q_l^{|u|+1}\}\subseteq P.w$ . To prove that  $P.w \subseteq \{q_l^1, q_l^2, ..., q_l^{|u|+1}\}\subseteq$ 
 $P.w$  it suffices to notice, that, from fact 2 automaton  $\mathcal{B}$  is deterministic and for
any prefix  $w'$  of  $w$  if  $Q_i.w' = \{q_{k_1}^i, ..., q_{k_s}^i\}$ , then  $Q_i.w' = \{q_{k_1}^i, ..., q_{k_s}^i\}$ .  $\Box$ 

**Lemma 2.** There exist an algorithm with  $O(|P||w|)$  time complexity and  $O(|P||w|)$  space complexity which computes a partition of P on sets  $Q_1, Q_2, ..., Q_{|w|+1}$ .

***Proof.*** We describe a desired algorithm. Suppose we have an array with  $|P|$  columns and  $|w| + 1$  rows. Put every element of  $P$  in a different column of a first row. Then we fill the *i*-th row by taking a state from the  $(i-1)$ -th row of the corresponding column and applying to it the *i*-th letter of a word  $w$  until the end of the row. After this procedure, from lemma 1, the last row contains only the states from the set  $\{q_i^1, q_i^2, ..., q_i^{|u|+1}\}$ . We can now compute each  $Q_i$  by taking those states from the first row that lie in the same columns as the state  $q_i^i$ . □

With these two lemmas we are ready to present a decryption method:

- 1. using Lemma 1 compute the set  $\{q_l^1, q_l^2, \dots, q_l^{|u|+1}\},$
- 2. using Lemma 2 compute the partition of P on sets  $Q_1, Q_2, ..., Q_{|u|+1}$ ,
- 3. for every transition  $x \in \{0,1\}$  in  $\mathcal{B}$  if x joins a states from different sets, say  $Q_i$  and  $Q_j$ , then join  $q_l^i$  and  $q_l^j$  with transition x, otherwise remove the transition.

Observe, that after applying that procedure to the ciphertext  $\mathcal{B}$  we end up with a graph that was our plaintext, what can be concluded directly from the encryption procedure. In general one can decipher the message only by knowing any carefully synchronizing word for  $\mathcal{A}$  or computing every possible induced subautomaton isomorphic to  $\mathcal{A}$ .

# 5 Extensions

As the ciphertext which is a result of our encryption method consists of  $n$  copies of isomorphic automaton with added transitions between those copies one can think of more “sophisticated” method of creating a ciphertext. As mentioned in the previous section a potential attacker can decipher the message computing every possible induced subautomaton isomorphic to a public key. However, the problem of determining for two given graphs say  $G$  and  $H$ , whether  $G$  has a copy of  $H$  as an induced subgraph is  $NP$ -complete [\[6\]](#page-9-1). In this section we present two lemmas that can be used to obfuscate the ciphertext even more. The first one involves adding the state to the public key and the second one adding arbitrary number of  $a$ -clusters to 

10

**Lemma 3.** Let  $A = (Q, \Sigma, \delta)$  be a PFA with carefully synchronizing word w. Further, let  $q \in Q$  be such that there exists  $p \in Q$  such that  $q \in p.a^{-1}$ . Let also  $A' = (Q \cup \{q'\}, \Sigma, \delta')$  where  $\delta'$  is defined as  $\delta$  on  $Q$  and  $\delta'(q', a) = q$ . Then  $w$  carefully synchronizes  $A'$ .

*Proof.* Since a is defined for all states of  $Q'$ , and  $|\Sigma| = 2$ , then the first letter of  $w$  must be a. Let  $w'$  be the word  $w$  without the first letter. Since  $\delta'(q', a) = q$  and we assumed that there exist  $p \in Q$  such that  $q \in p.a^{-1}$  it is straightforward, that  $Q'.a = Q.a$ . Since we have not added any other transitions to  $\mathcal{A}'$  and  $\delta'$  is defined as  $\delta$  on  $Q$ , we obtain that  $Q'.aw' = Q.aw' = Q.w$  and that concludes the proof.  $\Box$ 

For the next lemma we assume notation as in former part of the paper.

**Lemma 4.** Let  $\mathcal{B} = \bigcup_{i=1}^k A_k$  and  $m \in \mathbb{N}$  be the smallest integer such that  $Q.a^m = Q.a^{m+1}$ . Define  $B_i = Q_i.a^m b$  and let  $\mathcal{C}_1 = (S_1, \{a\}, \eta_1), \ldots, \mathcal{C}_l =$  $(S_l, \{a\}, \eta_l)$  be a-clusters with depth 1 and centers  $K_1, \ldots, K_l$  respectively. Let  $\mathcal{B}' = \mathcal{B} \cup \bigcup_{i=1}^l \mathcal{C}_i = (P', \Sigma, \rho').$  If we define b transitions for all states  $q \in$  $\bigcup_{i=1}^l K_i$  such that there exists  $0 < j < k+1$  such that  $\rho'(q,b) \in B_j$  then  $P'.w = \{q_l^1, ..., q_l^k\}.$ 

*Proof.* Since a is the only letter defined for all states in  $\mathcal{A}$  and  $Q.a^m = Q.a^{m+1}$  then *w* starts with a word  $a^{m_1}b$  for  $0 < m_1 < m+1$ . Note  $w = a^{m_1}bw'$  Observe that  $Q.a^{i+1} \subseteq Q.a^i$  for all  $i \geq 0$ . From that we have, that  $Q.a^m \subseteq Q.a^{m_1}$  and further for all copies of  $\mathcal{A}$  in  $\mathcal{B}'$  we obtain that  $B_i \in Q_i.a^{m_1}.b$ . Also, since the depth of any cluster  $C_i$  is 1, we have that  $P_j.a^{m_1} = K_j$  for all  $0 < j < m + 1$ . Notice that  $P' = \bigcup_{i=1}^k Q_i \cup \bigcup_{i=1}^l S_i$ , so

$$
P'.w = \bigcup_{i=1}^{k} Q_i.w \cup \bigcup_{i=1}^{l} S_i.w = \bigcup_{i=1}^{k} Q_i.a^{m_1}bw' \cup \bigcup_{i=1}^{l} S_i.a^{m_1}bw'
$$

$\text{which gives}$ 

$$
P'.w = \bigcup_{i=1}^{k} B_i w' \cup \bigcup_{i=1}^{l} K_i bw'.
$$

But we know, that for all  $q \in \bigcup_{i=1} K_i$  there exists  $0 < i < k+1$  such that  $\delta'(q, b) \in B_i$ . From that we obtain

$$
P'.w = \bigcup_{i=1}^{k} B_i w'.
$$

and since each  $B_i = Q_i a^m b$  then  $B_i w' = Q_i a^m b w' = Q_i w = \{q_l^i\}$  and that concludes the proof. □

Using these two lemmas we can move on to the description of the extended method of encryption and decryption. In the next two subsections we follow the notation provided in sections  $3$  and  $4$ .

11

## $5.1$ Extended encryption

The extension consists of adding two stages between the  $1$  and  $2$  stage of encryption method, defining sets  $Q'_i$  and substitute them for  $Q_i$  in latter stages. Let us state two additional stages:

- 1. add  $l$  a-clusters with depth 1 to automaton obtained in stage 1 and define letters  $b$  for centers of those clusters to fulfill assumptions of lemma 4 in  $\rho$  function (defined in section 3)
- 2. for each copy  $\mathcal{A}_i$  of public key in automaton obtained in previous stage add  $k_i$  states and define transitions as in lemma 3 and note the set of the added states in this stage as  $A_i$  for each  $\mathcal{A}_i$

Now let us define sets  $Q'_i$ . For clusters  $C_1 = (S_1, \{a\}, \gamma_1), \dots, C_l = (S_l, \{a\}, \gamma_l)$  (from stage 1) with centers  $K_1, \dots, K_l$  respectively we define sets  $C_1, \dots, C_{\|u\|+1}$ , such that if for  $q \in K_i$  it holds  $\rho(q, b) \in B_j$  (notation from lemma 4), then  $q$  and its branch belong to the set  $C_j$ . Then define  $Q'_i = Q_i \cup A_i \cup C_i$ . It is a simple exercise to prove that the sets  $Q'_1, \dots, Q'_{\|u\|+1}$  form a partition of  $P = \bigcup_{i=1}^{\|u\|+1} Q_i \cup A_i \cup C_i$  which is the set of all states of our ciphertext. The latter stages remain as in section 3.

## $5.2$ Extended decryption

Algorithm of deciphering is similar to the one described in section 4. We state lemmas being in a strict correspondence with those proven in section  $4$ .

**Lemma 5.** Let  $\mathcal{B}$  be a ciphertext computed by extended encryption method using public key  $\mathcal{A} = (Q, \Sigma, \delta)$  and  $Q.w = q_l$ . After removing letters  $x \in \{0, 1\}$  from automaton  $\mathcal{B}$  we have that  $P.w = \{q_l^1, q_l^2, \dots, q_l^{\vert u \vert +1}\}$ .

*Proof.* Observe that after stage 1 we can apply Lemma 4 and we obtain that  $(\bigcup_{i=1}^{|u|+1} Q_i \cup C_i).w = \{q_i^1, q_i^2, \dots, q_i^{|u|+1}\}\$ . Notice that after stage 2 we can apply Lemma 3 to any copy of public key that was modified by that stage and also  $P.w = \{q_i^1, q_i^2, \ldots, q_i^{|u|+1}\}\$ . The rest of the proof is similar to the proof of Lemma 1.  $\Box$ 

**Lemma 6.** There exist an algorithm with polynomial time complexity (depending on  $|P|$  and  $|w|$ ) which computes a partition of P on sets  $Q'_1, Q'_2, ..., Q'_{|w|+1}$ .*Proof.* Using approach from the proof of Lemma  $2$  we can compute similar matrix, say  $M$ , in time  $O(|P||w|)$ . From Lemma 6 we know the last row contains only the states from the set  $\{q_l^1, q_l^2, \ldots, q_l^{|u|+1}\}$  and we can compute sets  $\overline{Q}_1,\ldots,\overline{Q}_{|u|+1}$  such if column of the first row containing  $q$  is the same as the column of the last row containing  $q_l^i$ , then  $q \in \overline{Q}_i$ . Notice that there are three cases, when  $q \in \overline{Q}_i

$ :•  $q \in Q_i$ 

12

- $\bullet \ q \in A_i$
- $q \in S_m$  such that there exist  $p \in C_i \cap S_m$  (notation from Lemma 4)

First two cases are straightforward. To prove the theorem for the third case observe that if  $q \notin Q_i \cup A_i$ , then  $q \notin A_j$  and  $q \notin Q_k$  for any  $j, k \neq i$  otherwise  $\mathcal{B}$  would be non-deterministic. So we deduce that  $q \in S_m$  for some m. For the sake of contradiction suppose that  $C_i \cap S_m = \varnothing$ . But that means, that  $q.a^m b \in B_j$  for  $j \neq i$  and further  $q.ab^m w' = q.w = q_l^j$  what is a contradiction. From these considerations we are able to determine for each i the sets  $A_i$  and  $Q_i$  that are subsets of the set  $Q'_i$ . In order to compute the sets  $C_i$  we first compute  $S'_1, \ldots, S'_n$  inducing all a-clusters in  $\mathcal{B}$  by removing  $b, 0, 1$  transitions and determine all connected components of the resulting structure. Now we examine three cases for a cluster  $S'_j$ :

- $S'_i \cap \bar{Q}_i = \varnothing$
- $S'_i \subseteq \bar{Q}_i$
- $S'_i \cap \bar{Q}_i \neq \varnothing$  and  $S'_i \not\subset \bar{Q}_i$

Notice, that if the first case holds we know that no state of  $S'_j$  belongs to  $C_i$ . If the second case holds, we must check if  $S'_j \subseteq Q_i \cup A_i$ . If this is not true, then we have found a cluster  $C_m$ , such that for all  $q \in K_m$  it holds  $\rho(q,b) \in B_i$  and we determined the *a*-cluster that belongs to  $C_i$ . In the third case we know that some of the states of the cluster  $S'_j$  are in  $C_i$  and some are not. To compute those that are let us take the center of the a-cluster  $S'_j$ , say  $K'_j$ , and observe that  $q \in C_i$  if, and only if  $q \in \{p \in K'_j : \rho(p, b) \in B_i\} = K''_j$  or  $q$  belongs to some branch with destination in  $K''_j$ . That concludes the proof.

Using two former lemmas, decryption method is similar as in 4. Extended step is depicted on Figure 7. If we choose the public key to be the automaton on Figure 2, then notice, that in Lemma 4 we have  $m = 2$ , and  $Q.a^2b = \{2, 3, 7, 12, 13\}$ .

13

![](_page_13_Figure_0.jpeg)

Figure 7: Extended step of encryption.  $\mathcal{F}$ .

Observe that we can apply Lemma 3 to states  $1, 2, 3$ . 

We also added cluster that consists of states  $4, 5, 6, 7$  so we can apply Lemma 4. In the former method we had that  $Q_1 = \{1a,\dots,15a\}, Q_2 = \{1b,\dots,15b\}, Q_3 = \{1c,\dots,15c\}$  and now  $Q'_1 = Q_1 \cup \{1\}, Q'_2 = Q_2 \cup \{2,4,5\}, Q'_3 = Q_3 \cup \{3,6,7\}.$ 

# 6 Conclusions and further work

We proposed a method of utilizing careful synchronization to provide brand new public key cryptosystem. In sections  $3$  and  $4$  we presented core idea of our method and provided an example that illustrates it. As the ciphertext in that method consists of  $n$  copies of the same automaton, those two sections are included to so the reader could understand the method presented in section 5. It should be also mentioned that lemmas  $4$  and  $3$  are only examples of extensions of that cryptosystem. Indeed, observe that Lemma 4 provides a possibility to add "free"  $a$ -clusters to a ciphertext. The disadvantage of that extension is that

14

we only can add  $b$  transitions to states that are some specified states of the copy of the public key. It is possible also to add the extension, that allows us to define the  $a$ -clusters for which we can define  $b$  transition outside of that specific sets  $B_i$  but to whatever state we want, even the other added *a*-cluster. However this extension would cause that in Lemma 5 it would be only  $\{q_l^1,\dots,q_l^{|u|+1}\}\in P.w$  so the number of states added in such extensions would have been bounded by  $\min(|Q'_1|, \dots, |Q'_l|)$  and also demanded modifications in Lemma 6 so we omitted that extension.

Observe also that point  $2$  of encryption procedure can be modified in many ways. For example one can choose to define more than one transition between copies of automata and in decryption section choose the one that has odd or even number in a ciphertext. We end up with several questions and open problems:

**Question 1.** What is the most reasonable way to define lacking transitions in  $point 3?$ 

It is straightforward that if all lacking transitions in a copy of a public key are defined within the same copy, it would result with  $|u| + 1$  connected automata which are not connected between each other, and that simplifies the attack on  $\text{the cryptosystem.}$ 

**Question 2.** What is the most reasonable way to define transitions in point $4$ ?

We have defined step  $4$  in an abstract way, so to investigate many versions of adding those "obfuscating"  $\{0, 1\}$  transitions.

**Question 3.** Find an algorithm that generates pairs of public and private keys.

We believe that the most promising approach will be to construct a PFA that is carefully synchronized by a given  $w$ . We also want to investigate if it is possible to design an algorithm that for a given word  $w$  generates  $n$  nonisomorphic PFA's that are carefully synchronized by  $w$ . Having that one could take as a public key a tuple of  $n$  automata that are synchronized by the same word  $w$ . In that case, all methods presented in the paper would need only slight modifications to work properly.

# References

- [1] M. Berlinkov. On Two Algorithmic Problems about Synchronizing Automata. Language and Automata Theory and Applications, pages  $61-67$ , 2014.
- [2] M. Berlinkov and M. Szykuła. Algebraic Synchronization Criterion and Computing Reset Words. *Information Sciences*, 369:718–730, 2016.
- [3] M. T. Biskup and W. Plandowski. Shortest Synchronizing Strings for Huffman Codes. Theoretical Computer Science, 410:3925–3941, 2009.
- [4] J. H. Ellis. The Possibility of Non-Secret Digital Encryption. 1970.

15

- [5] D. Eppstein. Reset Sequences for Monotonic Automata. SIAM J. of Com $puting, 19:500-510, 1990.$
- [6] M. R. Garey and D. S. Johnson. Computers and Intractability; A Guide to the Theory of NP-Completeness. W. H. Freeman & Co., USA, 1990.
- [7] B. Imreh and M. Steinby. Directable Nondeterministic Automata.  $Acta$  $Cybern., 14:105-115, 1999.$
- [8] H. Jürgensen. Synchronization. Information and Computation, 206:1033– 1044, 2008.
- [9] J. Kari. A Counter Example to a Conjecture Concerning Synchronizing Word in Finite Automata. *EATCS Bulletin*, 73:146–147, 2001.
- [10] J. Kari. Synchronizing Finite Automata on Eulerian Digraphs. *Theoretical* Computer Science, 295:223-232, 2003.
- [11] T. Massart L. Doven and M. Shirmohammadi. Robust Synchronization in Markov Decision Processes. *CONCUR*, pages 234–248, 2014.
- [12] T. Massart L. Doyen and M. Shirmohammadi. The Complexity of Synchronizing Markov Decision Processes. J. Comput. Syst. Sci., 100:96–129, 2019.
- [13] P. Martyugin. Computational Complexity of Certain Problems Related to Carefully Synchronizing Words for Partial Automata and Directing Words for Nondeterministic Automata. Theory Comput Syst, 54:293–304, 2014. doi:10.1007/s00224-013-9516-6.
- [14] M.Ito and K. Shikishima-Tsuji. Some Results in Directable Automata. Theory Is Forever. Essays Dedicated to Arto Salomaa on the Occasion of His 70th Birthday [Lect. Notes Comp. Sci 3113], pages 125–133, 2004.
- [15] B. K. Natarajan. An Algorithmic Approach to the Automated Design of Parts Orienters. Foundations of Computer Science, 27th Annual Sympo $sium \ on, \ pages \ 132-142, \ 1986.$
- [16] J. E. Pin. On Two Combinatorial Problems Arising from Automata Theory. Proceedings of the International Colloquium on Graph Theory and  $Combinatorics, 75:535-548, 1983.$
- [17] L. Adleman R.L. Rivest, A. Shamir. A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. Communications of the ACM.,  $21:120-126, 1978.$
- [18] I. K. Rystsov. Reset Words for Commutative and Solvable Automata. Theoretical Computer Science, 172:273–279, 1997.
- [19] S. Sandberg. Homing and Synchronizing Sequences. *Model-Based Testing* of Reactive Systems, 3472:5–33, 2005.

16

- [20] M. Szykuła. Improving the Upper Bound on the Length of the Shortest Reset Word.  $STACS$  2018, pages 56:1–56:13, 2018.
- [21] R. Tao. Finite Automaton Public Key Cryptosystems, pages  $347 - 393.$ Springer Berlin Heidelberg, Berlin, Heidelberg, 2009. doi:10.1007/978-3-540-78257-5\_9.
- [22] A. Trahtman. The Černý Conjecture for Aperiodic Automata. *Discrete* Math. Theor. Comput. Sci., 9:3-10, 2007.
- [23] J. Černý. Poznámka k homogénnym eksperimentom s konečnými automatami. Mat.-Fyz. Cas. Slovens.Akad. Vied., 14:208–216, 1964.
- [24] M. Volkov. Synchronizing Automata and the Cerný Conjecture. Language and Automata Theory and Applications, 5196:11–27, 2008.
- [25] M. Volkov. Slowly Synchronizing Automata with Idempotent Letters of Low Rank. Journal of Automata, Languages and Combinatorics, 24:375-386, 2019.
- [26] V. Vorel. Subset synchronization and careful synchronization of binary finite automata. Jour. Found. Comput. Sci., 27:557–578, 2016.
- [27] M.E. Hellman W. Diffie. New Directions in Cryptography. *IEEE Transac*tions on Information Theory.,  $22:644-654$ ,  $1976$ .

17
