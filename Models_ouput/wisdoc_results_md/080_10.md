Proof. It is immediate from construction, since we have not removed any tran- i sitions from Σ within any Qi, that for any Qi ∈ P holds Qi.w = q , since w l

carefully synchronizes A and each Qi on Σ induces an isomorphic copy of A. So |u|+1 |u|+1 2 1 2 we have, that {q1l , q , .., q } ⊆ P.w. To prove that P.w ⊆ {q , q , .., q } ⊆ l l l l l

P.w it suffices to notice, that, from fact 2 automaton B is deterministic and for ′ i any prefix w′ of w if Q.w′ = {qk1 , .., qks}, then Qi.w = {qik1 , .., q }. ks

Lemma 2. There exist an algorithm with O(|P ||w|) time complexity and O(|P ||w|) space complexity which computes a partition of P on sets Q1, Q2, ..., Q|u|+1.

Proof. We describe a desired algorithm. Suppose we have an array with |P | columns and |w| + 1 rows. Put every element of P in a different column of a first row. Then we fill the i-th row by taking a state from the (i − 1)-th row of the corresponding column and applying to it the i-th letter of a word w until the end of the row. After this procedure, from lemma 1, the last row contains |u|+1 2 only the states from the set {q1l , q , .., q }. We can now compute each Qi by l l

taking those states from the first row that lie in the same columns as the state qil .

With these two lemmas we are ready to present a decryption method:

|u|+1 2 1. using Lemma 1 compute the set {q1l , q , .., q }, l l

2. using Lemma 2 compute the partition of P on sets Q1, Q2, ..., Q|u|+1,

3. for every transition x ∈ {0, 1} in B if x joins a states from different sets, j i say Qi and Qj, then join q and q with transition x, otherwise remove l l the transition.

Observe, that after applying that procedure to the ciphertext B we end up with a graph that was our plaintext, what can be concluded directly from the encryption procedure. In general one can decipher the message only by knowing any carefully synchronizing word for A or computing every possible induced subautomaton isomorphic to A.

5 Extensions

As the ciphertext which is a result of our encryption method consists of n copies of isomorphic automaton with added transitions between those copies one can think of more ”sophisticated” method of creating a ciphertext. As mentioned in the previous section a potential attacker can decipher the message computing every possible induced subautomaton isomorphic to a public key. However, the problem of determining for two given graphs say G andH , whether G has a copy of H as an induced subgraph is NP -complete [6]. In this section we present two lemmas that can be used to obfuscate the ciphertext even more. The first one involves adding the state to the public key and the second one adding arbitrary number of a-clusters to the ciphertext.